### 3-1 通用泛型映射方案（1）

> 001 继续我们的 spu 的 specs 字段

- 访问 http://localhost:8080/v1/spu/id/2/detail 
- 你会看到 specs 返回的是一个字符串
```
specs: "[
    {"key": "颜色", "value": "金属灰", "key_id": 1, "value_id": 45}, 
    {"key": "图案", "value": "七龙珠", "key_id": 3, "value_id": 9}, 
    {"key": "尺码", "value": "小号 S", "key_id": 4, "value_id": 14}]"
```

> 002 我们想要的是 对象这种格式而不是字符串

```
@Entity
@Getter
@Setter
public class Sku extends BaseEntity{
    //   ...
    // private String specs; // 由于这里定义为 String 所以是字符串
    
    // 我们想要的是 对象 ,但是 这样会有一个拆装箱过程，影响 specs的序列化
    // private Object specs; 
    
    // 考虑定义我们的 类
    private List<Spec> specs;
}
```

> 003 定义 Spec.java

- 注意！！！ 不需要打上 @Entity
- 因为它没有对应数据库的表,只是我们为了处理实际业务，自定义的类解决返回的是字符串问题

```
@Getter
@Setter
public class Spec {
    private Long keyId;
    private String key;
    private Long valueId;
    private String value;
}
```

> 004 修改 sku.java

- 直接修改为 `List<Spec>`是不行的,因为数据库表里存的是字符串，无法映射成 `List<Spec>` 类型

```
public class Sku extends BaseEntity{
    // ...
    
    private Long rootCategoryId;
    // 但是代码会标红 提示 你 'Basic' attribute type should not be a container
    private List<Spec> specs;
}
```

> 005 利用 getter/setter 方法做转化

- 因为序列化到前端时 会调用 getter / setter 方法
- @Getter / @Setter 默认生成的方法我们无法使用
- 我们这里用 单独给 specs 写一个 get方法 这样读取的时候，就会使用我们定义的`getSpecs`

```
@Entity
@Getter
@Setter
public class Sku extends BaseEntity{
    @Id
    private Long id;
    private BigDecimal price;
    private BigDecimal discountPrice;
    private Boolean online;
    private String img;
    private String title;

    private Long spuId;
    private Long categoryId;
    private Long rootCategoryId;

    private String specs;
    private String code;
    private Long stock;

    public List<Spec> getSpecs(){
        String specs = this.specs;
        // Jackson 等序列化库
        return null;
    }
    
     public void setSpecs(List<Spec> data){
        String str = "data序列化后的字符串";
        this.specs = str;
    }
}
```

### 3-2 通用泛型类映射方案（2）

> 3-1的方案 非常麻烦

- 实际项目中，可能不止一个地方存在 类似 specs 这样的字段
    - 难道每次都重写 getter/setter 方法，然后定义一个 Spec 类？
- 必须手动写 getter/setter 

> #### 我们的方案

- 使用一种通用的数据结构表示JSON对象
    - Map<String,Object>
    - List<Object>
- 但是它不是一个基本类型 就会提示 "'Basic' attribute type should not be a container"
    - 因为它无法直接和我们的数据库 json字段做映射

**我们要做的是**

- 写一次的转换关系，然后在任何的实体里 都可以把这种 json的字段转换成 Map 或者 List 这种形式
    - 解决了 3-1 每次都要单独定义 额外的类做处理
    - 解决了 每次在实体里写 getter/setter 处理 json问题

```
public class Sku extends BaseEntity{

    // private List<Object> specs;
    private Map<String,Object> specs;

}
```

我们的数据库里的 specs 实际是一个 数组 