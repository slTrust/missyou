### 3-6 多对多关系配置@ManyToMany

Theme.java

```
@Entity
public class Theme {
    @Id
    private Long id;
    private String title;
    private String name;

    // 导航属性
    @ManyToMany
    private List<Spu> spuList;
}
```

Spu.java

```
@Entity
public class Spu {
    @Id
    private Long id;
    private String title;
    private String subtitle;

    // 导航属性
    @ManyToMany
    private List<Theme> themeList;
}
```

> 查看生成的表是什么样子的

结果生成四张表

```
spu / theme 不说了
spu_theme_list(spu_id,theme_list_id)
theme_spu_list(theme_id,spu_list_id)
```

**因为这是双向多对多**

### 3-7 单向多对多关系配置与常见问题

Spu.java

```
@Entity
public class Spu {
    @Id
    private Long id;
    private String title;
    private String subtitle;
}
```

Theme.java

```
@Entity
public class Theme {
    @Id
    private Long id;
    private String title;
    private String name;

    // 导航属性
    @ManyToMany
    private List<Spu> spuList;
}
```

> 此时生成三个表

```
spu
theme
theme_spu_list(theme_id,spu_list_id)  关系表
```

- 我们不想要生成的关系表叫做 theme_spu_list 而是 theme_spu 才对
- 而且 theme_spu_list 里的字段 spu_list_id 应该是 spu_id 才对

> 指定表名,和外键的名称

```
@Entity
public class Theme {
    @Id
    private Long id;
    private String title;
    private String name;

    // 导航属性
    @ManyToMany
    @JoinTable(name="theme_spu",joinColumns = @JoinColumn(name = "theme_id"),
    inverseJoinColumns = @JoinColumn(name="spu_id"))
    private List<Spu> spuList;
}
```

这样生成的关系表就是 `theme_spu(theme_id,spu_id)`


### 3-8 双向多对多配置

- 跟双向一对多一样，都要指定 关系的维护端 / 关系的被维护端

**确定 主控方(关系的维护端)**，如果两边都是对等的，都有导航属性，而且都有`@ManyToMany`

这是JPA无法确定 谁是维护端。 所以会生成 四个表

**那一方有 mappedBy 那一方就是 被维护端**

> Spu.java

```
@Entity
public class Spu {
    @Id
    private Long id;
    private String title;
    private String subtitle;

    //导航属性
    @ManyToMany(mappedBy = "spuList") //
    private List<Theme> themeList;
}
```

> Theme.java

```
@Entity
public class Theme {
    @Id
    private Long id;
    private String title;
    private String name;

    // 导航属性
    @ManyToMany
    @JoinTable(name="theme_spu",joinColumns = @JoinColumn(name = "theme_id"),
    inverseJoinColumns = @JoinColumn(name="spu_id"))
    private List<Spu> spuList;
}
```

针对我们这个 spu / theme 关系维护端和被维护端可以相互颠倒。

针对**查询**来说，无论谁是 关系维护端还是被维护端都没有关系。

> ####  不推荐用 JPA 做删除和更新

- 因为涉及到一个**级联**问题和 **去孤子** 问题。
- 另外一个现在都是 逻辑删除，而不是物理删除记录。

