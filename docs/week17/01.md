### 1-1 Java的泛型是编译期间的而非运行期间

> 继续之前的问题 Sku.java

- 如果这里是 `List<Object> specs;` 那么 这里丧失了处理业务的能力
- 但是如果这里这样 `List<Spec> specs;` 就不得不做对应的 序列化工具类 SpecAndJson 

```
public class Sku extends BaseEntity{
    // ...   

    @Convert(converter = ListAndJson.class)
    private List<Object> specs;

}
```

> #### 如何保持强类型的特性，又不用每次新增一个具体类 Spec 去新增一个 处理序列化的类 SpecAndJson

**泛型:存在两个问题**

第一个问题：

- `AttributeConverter<List<Object>,String>` 替换第一个参数为 T => `AttributeConverter<T,String>`
- 序列化的时候不需要考虑具体类型，但是反序列化的时候必须传递元类 `mapper.readValue(s, List.class);`
    - 这个地方是不能直接 `T.class`的

第二个问题： 

- 你调用`@Converter`的时候需要 把反序列化 元类 传入进来
- 而 `@Converter` 它的使用方式是这样，我该如何把 这个 元类传入进来
    ```
    @Convert(converter = ListAndJson.class)
    private List<Object> specs;
    ```

```
@Converter
public class ListAndJson implements AttributeConverter<List<Object>,String> {
    @Autowired
    private ObjectMapper mapper;
    @Override
    public String convertToDatabaseColumn(List<Object> objects) {
        try {
            return mapper.writeValueAsString(objects);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            // 要向前端反馈没意义， 应该返回错误,记录日志
            throw new ServerErrorException(9999);
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public List<Object> convertToEntityAttribute(String s) {
        try {
            if(s==null){
                return null;
            }
            List<Object> t = mapper.readValue(s, List.class);
            return t;
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            throw new ServerErrorException(9999);
        }
    }
}

```

### 1-2 通用泛型类与强类型转换 （1）

> #### 一个难点：

```
public class GenericAndJson {
    @Autowired
    private static ObjectMapper mapper;
}

// 在静态类变量打上 自动注入是不合理的
```

- 通过 setter 做桥接，依赖注入和 static 成员变量之间的关系

```
public class GenericAndJson {

    private static ObjectMapper mapper;

    @Autowired
    public void setMapper(ObjectMapper mapper){
        GenericAndJson.mapper = mapper;
    }
}
```



- 定义我们的工具类 GenericAndJson.java


```
public class GenericAndJson {

    private static ObjectMapper mapper;

    @Autowired
    public void setMapper(ObjectMapper mapper){
        GenericAndJson.mapper = mapper;
    }

    public static <T> String objectToJson(T o){
        try {
            return GenericAndJson.mapper.writeValueAsString(o);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            // 要向前端反馈没意义， 应该返回错误,记录日志
            throw new ServerErrorException(9999);
        }
    }

   public static <T> T jsonToObject(String s, Class<T> classT){
       try {
           if(s==null){
               return null;
           }
           T o = GenericAndJson.mapper.readValue(s, classT);
           return o;
       } catch (JsonProcessingException e) {
           e.printStackTrace();
           throw new ServerErrorException(9999);
       }
   }

}
```