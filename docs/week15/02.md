### 2-1 访问Banner接口

> 录入数据

```
INSERT INTO `banner` VALUES ('1', 'b-1', '首页顶部主banner', '2020-03-25 03:31:31.967', '2020-03-25 03:31:45.818', null, null, null), ('2', 'b-2', '热销商品banner', '2020-03-25 03:32:17.741', '2020-03-25 03:32:27.303', null, null, 'http://i2.sleeve.7yue.pro/m4.png');

INSERT INTO `banner_item` VALUES ('5', 'http://i2.sleeve.7yue.pro/m6.png', '28', '1', '2020-03-25 03:34:12.521', '2020-03-25 03:35:22.602', null, '2', 'left'), ('6', 'http://i2.sleeve.7yue.pro/m7.png', '26', '1', '2020-03-25 03:35:15.661', '2020-03-25 03:35:15.661', null, '2', 'right-top'), ('7', 'http://i2.sleeve.7yue.pro/m8.png', '27', '1', '2020-03-25 03:35:45.819', '2020-03-25 03:35:45.819', null, '2', 'right-bottom'), ('12', 'http://i2.sleeve.7yue.pro/m1.png', 't-2', '3', '2020-03-25 03:33:09.677', '2020-03-25 03:33:09.677', null, '1', null), ('13', 'http://i1.sleeve.7yue.pro/assets/702f2ce9-5729-4aa4-aeb3-921513327747.png', '23', '1', '2020-03-25 03:33:33.323', '2020-03-25 03:33:33.323', null, '1', null), ('14', 'http://i1.sleeve.7yue.pro/assets/b8e510a1-8340-43c2-a4b0-0e56a40256f9.png', '24', '1', '2020-03-25 03:33:50.051', '2020-03-25 03:33:50.051', null, '1', null);
```

> 访问接口

```
http://localhost:8080/v1/banner/name/b-1

http://localhost:8080/v1/banner/name/b-2
```

### 2-2 @MappedSuperclass 的作用

**标识一个类是另一个类的父类**

> 访问 http://localhost:8080/v1/banner/name/b-1

- 发现返回的 json 里有 createTime/updateTime/deleteTime，但值为 null
- 因为 banner / bannerItem 继承了 BaseEntity 但是 它的字段没被映射

> 解决方案

- 添加`@MappedSuperclass` 注解

```
@Getter
@Setter
@MappedSuperclass
public abstract class BaseEntity {

    private Date createTime;
    private Date updateTime;
    private Date deleteTime;
}
```

### 2-3 Jaskson序列化库的重要配置（SNAKE_CASE、时间戳)

> 一个疑问 "Banner"设置为懒加载，但是 它的 items还是查出来了？

- 这是因为在序列化的时候，触发了这个懒加载
    - 由于有`@Getter`,在序列化的时候，回去调用 items的 get方法，就会去读取 items

```
@OneToMany(fetch = FetchType.LAZY)
@JoinColumn(name="bannerId")
private List<BannerItem> items;
```

> #### spring boot 里默认的序列化库

- jackson 

> #### 设置返回的字段格式 和 修改 GMT时间为时间戳

- `property-naming-strategy: SNAKE_CASE` 字段格式为 下划线连接
- `WRITE_DATES_AS_TIMESTAMPS` 设置 GMT时间转换为 时间戳
- [一些配置参数信息](https://my.oschina.net/u/2474629/blog/3126804)

```
createTime => create_time
updateTime => update_time
deleteTime => delete_time
```

修改 application.yml

```
spring:
  profiles:
    active: dev

  jpa:
    hibernate:
      ddl-auto: none
  jackson:
    property-naming-strategy: SNAKE_CASE
    serialization:
      WRITE_DATES_AS_TIMESTAMPS: true

missyou:
  api-package: com.lin.missyou.api
```

> 如何不序列化某些字段

- `@JsonIgnore`

```
@Getter
@Setter
@MappedSuperclass
public abstract class BaseEntity {

    @JsonIgnore
    private Date createTime;
    @JsonIgnore
    private Date updateTime;
    @JsonIgnore
    private Date deleteTime;
}
```

> banner 可能找不到

- 我们要做处理，找不到返回一个错误 json 格式

```
public class BannerController {

    @Autowired
    private BannerService bannerService;

    @GetMapping("/name/{name}")
    public Banner getByName(@PathVariable @NotBlank String name){
        Banner banner = bannerService.getByName(name);
        if(banner == null){
            throw new NotFoundException(30005);
        }
        return banner;
    }
}
```

### 2-4 Theme接口开发

### 2-5 Theme表设计

```
CREATE TABLE `theme` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  -- 前端展示的 主题标题
  `title` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `description` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  -- 用于后端的标识
  `name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `create_time` datetime(3) DEFAULT CURRENT_TIMESTAMP(3),
  -- 前端使用那个模块 通过这个字段配置
  `tpl_name` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  `update_time` datetime(3) DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),
  `delete_time` datetime(3) DEFAULT NULL,
  -- 入口的图片
  `entrance_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  -- 暂无意义， 已被扩展字段时使用
  `extend` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  -- 点击一个主题后，主题详情页的顶部图片
  `internal_top_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  -- 前端 "热卖榜单"这种图片标题， 产品最开始可能没有，但是后期改变可能会要求有这个标题 而且还是可配的，这样能避免业务的变更
  `title_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci DEFAULT NULL,
  -- 代表这个主题是否上线
  `online` tinyint(3) unsigned DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
```

### 2-6 表的列行转换思维

> 扩展数据库

- 表里 “数据字段不够”

```
// 举个例子
theme表， 现在是带 颜色的 具有 color字段

// 过了几周 产品提出需求， 我还需要其他颜色,这就是典型的字段不够用
theme(color1,color2,color3)

如果你一开始就想好 color 可能有多个  那你开始就可以 添加上 color1,color2,color3 

- 很明显 color1,color2,color3 都是同一种属性的字段，都表示“颜色”

你在设计数据库的时候，就该考虑 theme 和 color 是一种 一对多的关系
是不是可以多一个 Color 表去 维护 color1 color2 color3
```

> 对于一张表来说

- **字段不具备扩展性**
- **记录是具备扩展性的**
- 列 不具备扩展性
  - 如果刚才的例子把 color设计成字段，那么它就是列，不具备扩展性
- 行 随意新增
  - 而我们通过某种方式，把color变成一个表，那么未来新增 color的时候就不是新增字段了，而是新增“行”

> 一个巧妙配置的应用

```
Key / Config 表

id  name    value table_name
1   color1  green  theme
2   color2  red    theme
...
4   name     热卖    banner
```











